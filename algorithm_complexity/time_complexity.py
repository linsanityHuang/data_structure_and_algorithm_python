'''
03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？
'''

'''
几种常见时间复杂度实例分析

虽然代码千差万别，但是常见的复杂度量级并不多。
我稍微总结了一下，这些复杂度量级几乎涵盖了你今后可以接触的所有代码的复杂度量级。
'''

'''
复杂度量级（按量级数递增）

常量阶				O(1)
对数阶 				O(logn)
线性阶 				O(n)
线性对数阶			O(nlogn)
平方阶				O(n^2)
立方阶				O(n^3)
k次方阶				O(n^k)

指数阶				O(2^n)
阶乘阶				O(n!)
'''

'''
对于刚罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2^n) 和 O(n!)。

我们把时间复杂度为非多项式量级的算法问题叫作NP（Non-Deterministic Polynomial，非确定多项式）问题。

当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。

所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度我就不展开讲了。我们主要来看几种常见的多项式时间复杂度。
'''

'''
1、O(1)

首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。

比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。

只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。

或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是O(1)。
'''
i = 8
j = 6
sum_ = i + j


'''
2、O(logn)、O(nlogn)
对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。我通过一个例子来说明一下。
'''
i = 1			# 1
n = 1000		# 2
while i <= n:	# 3
	i *= 2		# 4

'''
根据我们前面讲的复杂度分析方法，第四行代码是循环执行次数最多的。
所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。

从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。
还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：

2^0	2^1	2^2	2^3	2^4	2^5	2^6	2^x = n

所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2^x=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。
x=log2n，所以，这段代码的时间复杂度就是 O(log2n)

现在，我把代码稍微改下，你再看看，这段代码的时间复杂度是多少？
'''
i = 1
while i <= n:
	i *= 3

'''
根据我刚刚讲的思路，很简单就能看出来，这段代码的时间复杂度为 O(log3n)。
实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？
我们知道，对数之间是可以互相转换的。
'''

'''
如果你理解了我前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。

还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。

而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。
'''


'''
3、O(m+n)、O(m*n)

我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。老规矩，先看代码！
'''


def cal(m, n):
	sum_1 = 0
	for i in range(1, m):
		sum_1 += i

	sum_2 = 0
	for j in range(1, n):
		sum_2 += j
	
	return sum_1 + sum_1


'''
从代码中可以看出，m 和 n 是表示两个数据规模。
我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。
所以，上面代码的时间复杂度就是 O(m+n)。

针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。
但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。
'''